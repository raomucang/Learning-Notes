# 泛型

[发现这里已经有很详细且我能看懂的讲解，就不需要再抄一遍。。。以后有新的发现再补充本文档吧](https://blog.csdn.net/s10461/article/details/53941091)

## 泛型的定义

泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法
 ———————————————— 
版权声明：本文为CSDN博主「VieLei」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/s10461/article/details/53941091

### 泛型类

``` java
//泛型类的定义
public class Demo<T> {
    private T t;

    //这并不是泛型方法，这只是一个使用了泛型参数的普通类
    public Demo(T t) {
        this.t = t;
    }

    public void show(){
        System.out.println(t);
    }
}

//泛型类的使用以及实例化
public class Test{
    public static void main(String[] args){
        String str = "HelloWorld!";
        Demo<String> demo = new Demo<String>(str);
        demo.show();
    }
}
```

我们可以看到，在定义`Demo`类时，我们使用符号`T`来声明`Demo`类的成员属性`t`，这时`T`还不是一个确定的类型，而在我们实例化`Demo`类时才确定`T`，而我们这里确定的类型为"String"，这时`T`就被确定下来为`String`，这里也可以传入其他类型，但不能是基本类型。

简而言之泛型可以用来修饰泛型类中的成员属性，成员方法的类型，而这些成员属性，成员方法具体的类型是在实例化类时看确定的类型是什么而定的。

### 泛型方法

```java
class Demo {
    //泛型方法
    public <T> void show(T t){
        System.out.println(t);
    }
}

//泛型方法的使用
public class Test{
    public static void main(String[] args){
        Demo demo = new Demo();
        //<String>可省略
        demo.<String>show("HelloWorld！");
    }
}

//需求定义方法
```

### 泛型接口

```java
public interface MyInterfaces<E> {
    public abstract add(E e);
}

//泛型接口上的泛型确定方式
//a.在实现类，实现该接口时，确定泛型的具体类型
class MyClass implements MyInterfaces<String>{
    public void add(String s){}
}
//b.在实现类，实现该接口时，确定泛型，继续保留
//此时这个实现类就是一个泛型类
class MyClass<E> implements MyInterface<E>{
    public void add(E e);
}

```

### 泛型通配符

格式：<?>
作用：代表任意泛型皆可
应用：主要用到方法的参数上

### 泛型的上下限

<?>代表任意泛型
上限<? extends Animal>: 代表泛型必须是Animal本类或者是Animal子类
下限<? super Dog>:代表泛型必须是Dog本类或者是Dog父类

