## day07【排序算法、异常、多线程基础】

#### 一. 冒泡排序

- 冒泡排序的核心思想: 依次比较相邻的两个元素


- 过程图解

  ![](BubbleSort.png)

- 代码实现

  ```java
  /**
   * 冒泡排序
   */
  public class BubbleSortDemo {
      public static void main(String[] args) {
          int[] arr = {4, 6, 1, 7, 9, 8, 3, 2, 5};
          //1.外层循环控制轮数
          for (int i = 0; i < arr.length - 1; i++) {
              //2.内存循环控制次数
              for (int j = 0; j < arr.length - 1 - i; j++) {
                  //3.比较相邻元素
                  if (arr[j] > arr[j + 1]) {
                      //4.交换
                      int temp = arr[j];
                      arr[j] = arr[j + 1];
                      arr[j + 1] = temp;
                  }
              }
          }
          //打印数组
          System.out.println(Arrays.toString(arr));
      }
  }
  ```

#### 二. 选择排序

- 核心思想: 固定选中某个元素,依次和以后的元素比较


- 过程图解

  ![](SelectSort.png)

- 代码实现

  ```java
  public class SelectSortDemo {
      public static void main(String[] args) {
          int[] arr = {4, 6, 1, 7, 9, 8, 3, 2, 5};
          //1.外层循环(可以理解为轮数,也可以理解为选中的元素)
          for(int i = 0;i < arr.length - 1;i++){
              //2.内层循环(与选中元素进行比较的元素)
              for (int j = i+1;j < arr.length;j++) {
                  //3.比较
                  if (arr[i] > arr[j]) {
                      //4.交换
                      int temp = arr[i];
                      arr[i] = arr[j];
                      arr[j] = temp;
                  }
              }
          }
          //5.打印
          System.out.println(Arrays.toString(arr));
      }
  }
  ```

#### 三. 二分查找

- 过程图解

- 代码实现

  ```java
  public class BinarySearchDemo {
      public static void main(String[] args) {
          //1.二分查找必须是有序的数组
          int[] arr = {1, 4, 6, 8, 9, 10, 30, 405, 607, 999};
          //2.调用方法
          System.out.println("请输入要查找的元素:");
          int key = new Scanner(System.in).nextInt();
          int index = binarySearch(arr, key);
          System.out.println("您要查找元素索引为:"+index);
      }

      /**
       * 定义一个方法,执行二分查找
       */
      public static int binarySearch(int[] arr, int key) {
          //1.定义开始和结束索引
          int start = 0;
          int end = arr.length - 1;

          while (start <= end) {
              //2.二分查找
              int mid = (start + end) / 2;
              //3.判断
              //a.如果正好相等,那么直接返回索引即可
              if (arr[mid] == key) {
                  return mid;
              } else if (arr[mid] > key) {
                  //如果 要找的数,比arr[mid]小,那么在左半部分找
                  end = mid - 1;
              } else {
                  //如果 要找的数,比arr[mid]大,那么在右半部分找
                  start = mid + 1;
              }
          }
          return -1;
      }
  }
  ```

  ​

#### 四.异常

##### 	1.什么是异常

```java
Java程序出现非正常的情况(异常不是语法错误!)
```

##### 	==2.异常的继承体系==

```java
a.所有异常和错误的父类:
		Throwable
b.Throwable的子类:
		Exception: 异常类(我们程序员要研究)
         Error: 错误类(不是我们程序员能解决的) 
c.Exception的子类:
		编译时异常(Exception以及其子类,但是RuntimeException除外): 在编译就会有异常发生!
		运行时异常(RuntimeException以及其子类): 在编译时就算有异常也不会提示,在运行时才会报错!
```

##### 	3.异常类中常用的三个方法

```java
public void printStackTrace(); "打印该异常对象的详细信息(包括异常的类型,异常的原因,异常的位置)
================以下两个方法我们做为了解=================  
public String getMessage() :获取发生异常的原因  
public String toString(); 获取异常的类型和异常原因
```

##### 	==4.异常(Exception)的分类==

- 编译时异常: 是指编译阶段就可以报的异常!


- 运行时异常: 是指编译阶段不会报错(有错,也不报错!),运行时才报错!!

##### 5.JVM异常产生过程(画图演示) 

![](JVM.png)

#### 五.异常处理

##### 	1.模拟JVM抛出异常(关键字throw)

```java
throw: 关键字,用于抛出异常对象
格式: throw 某个异常对象;
public class JVMExceptionDemo {
    public static void main(String[] args) {
        int[] arr = {1,2};
        //调用方法
        method(arr);
    }

    public static void method(int[] arr) {
        //模拟JVM抛出异常(练习throw关键字的使用)
        if (arr == null) {
            //抛出空指针异常
            throw new NullPointerException("您的数组arr为null");
        }
        if (arr.length < 3) {
            throw new ArrayIndexOutOfBoundsException("您的数组长度不够呦~~");
        }
        //访问第3个元素
        int num = arr[2];
        System.out.println(num);
    }
}
```

##### 	2.Objects类中提供的非空判断方法

```java
public static <T> T requireNonNull(T obj){
  	if(obj == null){
    	throw new NullPointerException();
  	}
  	return obj;
}
```

##### 	==3.遇到异常的2种处理方式==***************

- throws声明抛出异常

  ```java
  throws: 关键字,给方法做声明的
  作用: 表示该方法内部可能会有异常抛出,提示该方法的调用者,必须处理这个异常
  格式:
  		public void 方法名(参数列表) throws XxxException,YyyException,...{
           	方法体; 
           }
  ```


  public class ThrowsDemo {
      public static void main(String[] args)throws FileNotFoundException {
          //调用方法
          readFile("2.txt");
      }
    
      /**
       * 定义方法:用于读取硬盘上的某个文件内容
       */
      public static void readFile(String filename) throws FileNotFoundException {
          //假设硬盘上只有一个文件 1.txt
          if (filename.equals("1.txt")) {
              System.out.println("读出成功~~~");
          } else {
              throw new FileNotFoundException("您要的文件" + filename + "找不到!!!");
          }
      }
  }
  ```

- try..catch捕获异常

  ```java
  try...catch: 捕获异常(异常不会抛给JVM)
  格式:
  	try{
       	可能出现异常的代码; 
      }catch(XxxException e){
        	处理该异常
      }
  	System.out.println("程序是可以正常运行到这的...");


  public class TryCatchDemo {
      public static void main(String[] args) {
          //调用方法
          try {
              readFile("2.txt");
          } catch (FileNotFoundException e) {
              e.printStackTrace();
          }

          System.out.println("程序执行到这了.....");
      }

      /**
       * 定义方法:用于读取硬盘上的某个文件内容
       */
      public static void readFile(String filename) throws FileNotFoundException {
          //假设硬盘上只有一个文件 1.txt
          if (filename.equals("1.txt")) {
              System.out.println("读出成功~~~");
          } else {
              throw new FileNotFoundException("您要的文件" + filename + "找不到!!!");
          }
      }
  }

  ```

##### 	4.[扩展1]catch代码块中三种常见的处理方式

```java
a.开发阶段: 直接打印异常信息,程序员根据信息调整代码
b.测试阶段: 把异常信息保存到本地的异常数据库或者异常日志中
c.上线阶段: 把异常信息保存到用户的本地,在适当的时机上传服务器的异常系统
```

##### 	5.[扩展2]多个异常如何捕获处理

```java
案例:
	method01(); //可能抛出ExceptionOne
	method02(); //可能抛出ExceptionTwo
	method03(); //可能抛出ExceptionThree

如何捕获处理???
   a.每个异常分开处理: 一个异常一个trycatch
   		try{
   			method01();
   		}catch(ExceptionOne e1){
   			e1.printStackTrace();
   		}
   		try{
   			method02();
   		}catch(ExceptionTwo e2){
   			e2.printStackTrace();
   		}
   		try{
   			method03();
   		}catch(ExceptionThree e3){
   			e3.printStackTrace();
   		}
   b.所有异常一起捕获: 所有异常一个try一个catch[最常用]
   		try{
   			method01(); //可能抛出ExceptionOne
			method02(); //可能抛出ExceptionTwo
			method03(); //可能抛出ExceptionThree
   		}catch(Exception e){
   			//catch中必须写以上所有异常的共同父类,如果不知道其共同父类,写Exception肯定没错
   			e.printStackTrace();
   		}
   		
	c.所有异常一起捕获,分开出来: 所有异常一个try多个catch
		try{
			method01(); //可能抛出ExceptionOne extends ExceptionTwo
			method02(); //可能抛出ExceptionTwo
			method03(); //可能抛出ExceptionThree
		}catch(ExceptionOne e1){
			e1.printStackTrace();
		}catch(ExceptionTwo e2){
   			e2.printStackTrace();
   		}catch(ExceptionThree e3){
   			e3.printStackTrace();
   		}
   		
```

##### 	6.finally代码块

```java
格式:
	    try{
         	可能有异常的代码 
        }catch(XxxException e){
          	e.printStackTrace();
        }finally{
         	一般写必须要执行的代码 
            在开发中,写释放资源的代码(关闭IO流,关闭数据库连接,关闭网络连接)  
        }
注意: 无论什么情况下,finally代码块中的代码肯定会执行
```

##### 	7.异常的注意事项

```java
a.运行时异常被抛出可以不处理。即不捕获也不声明抛出(运行时异常编译时不管)
b.子类重写父类的方法, 重写后的方法能抛出异常的个数 <= 父类的方法抛出异常的个数
c.如果父类的方法没有抛出异常,那么子类重写该方法时也不能抛出异常
d.如果有资源需要释放,那么建议加上finally,如果没有资源释放不需要加finally
e.当多个异常,一个try多个catch捕获时,必须先捕获子类异常,后捕获父类异常(子类异常在前,父类异常在后捕获-
```

- ==总结:==

  ```java
  a.如果写代码过程中没有遇到异常,那就不用关心异常问题
  b.如果写代码过程中遇到异常呢???
    		i.如果是运行时异常,那么不需要try也不需要throws,只需运行后要根据异常信息修改代码即可
    		ii.如果是编译时异常,那么要么throws要么trycatch(目前没有要求,二选一即可)
  ```


#### 六.自定义异常

##### 	1.为什么要定义异常

```java
为什么要自定义异常:因为Java异常不可能描述所有的问题
```

##### 	2.自定义异常的步骤

```java
a.创建一个异常类(类名必须叫XxxException)
b.该类必须继承Exception或者RuntimeException 
c.自定义异常至少提供两个构造,无参构造+String参数的构造(String代表的异常的信息)
  
public class MyException extends /*Exception*/RuntimeException{

    public MyException(){

    }
    public MyException(String message){
      super(message);
    }
}
```

##### 	3.自定义异常的练习(代码演示)

```java
public class TestDemo {
    public static void main(String[] args) {
        //调用方法
        System.out.println("请输入您要注册的用户名:");
        String username = new Scanner(System.in).nextLine();
        try {
            register(username);
        } catch (RegisterException e) {
            e.printStackTrace();
        }
        System.out.println("程序也会执行到这...");
    }

    /**
     * 定义方法:注册
     */
    public static void register(String username) throws RegisterException {
        //判断用户名是否已经被占用
        //假设rose已经被注册
        if ("rose".equals(username)) {
            //注册失败
            throw new RegisterException("亲，该用户名已经被注册。");
        } else {
            //注册成功
            System.out.println("恭喜您" + username + "注册成功~~");
        }
    }
}
```

#### ==七.多线程************== 

##### 	==1.并行和并发==

- 并行(真的一起执行): 是指两件事,在同一时刻都在执行
- 并发(交替执行): 是指两件事,在同一时间段内都在执行

##### 	==2.进程和线程==  

- 进程: 正在内存中运行的程序

- 线程: 是指进程中完成某个特定功能的执行单元

   

-  进程和线程的一些区别(了解):

   ```java
   a.每个进程都是拥有独立的内存空间(栈和堆都是独立的)
   b.同一个进程中多个线程,拥有独立栈空间(从进程中申请),拥有共享堆空间(就是进程的堆空间)  
   ```

-  ==线程调度:==

   ```java
   "线程的调用是指:CPU在多个线程之间进行高速切换(人类根本无法感觉到),造成多个线程同时执行的假象"

   线程调度的分类:
   	分时调度: 每个线程平均轮流拥有CPU时间
   	抢占式调度: 每个线程随机分配CPU的时间

   Java的线程调度: 采用抢占式调度

   举例: 当我们右键运行main方法时,实际上我们运行是一个Java进程,而这个进程中是有多个线程的
   	  第一main所在的线程,主线程 第二垃圾回收线程 第三异常打印线程	
   ```

##### 3.Thread类**************

```java
Thread类就是Java中代表线程的类,只要创建一个该类对象,就是创建了一个线程对象

"Thread类的构造方法:
public Thread(); 创建线程对象不指定名字(默认名字Thread-0.Thread-1)
public Thread(String name); 创建线程对象指定名字

public Thread(Runnable r);
public Thread(Runnable r,String name);

"Thread类的成员方法:
public String getName(); 获取线程的名字
public void setName(String name); 获取线程的名字

public void start(); 开启线程(只是创建线程对象,但是不开启线程,那么线程是不会执行)
public void run(); 线程的任务方法,线程要执行的代码请写在该方法中

"Thread类的静态方法:
public static void sleep(long time);让"当前"线程"暂停"/"休眠"time毫秒
public static Thread currentThread();获取"当前"线程对象
```

##### 4.创建新的线程方式一_继承方式******

```java
API描述:
		一种方法是将类声明为 Thread 的子类。
		该子类应重写 Thread 类的 run 方法。
		接下来可以分配并启动该子类的实例
步骤:
	a.创建一个子类 extends Thread
	b.重写run方法(在run方法中写该线程需要执行的任务代码)
    c.创建子类对象(实际上就是创建了一个线程对象)  
    d.调用start方法启动线程即可 
    
/**
 * 1.创建一个子类 继承 Thread
 */
public class SubThread extends Thread{
    //2.重写run方法,添加代码
    @Override
    public void run() {
        //这个线程需要执行的任务
        for (int i = 0; i < 10; i++) {
            System.out.println("听歌" + i);
        }
    }
}

public class TestDemo {
    public static void main(String[] args) {
        //3.创建子线程对象
        SubThread st = new SubThread();
        //4.启动子线程
        st.start();

        //主线的代码
        for (int i = 0; i < 10; i++) {
            System.out.println("吃饭" + i);
        }
    }
}		
```

##### 5.创建新的线程方式二_实现方式**************

```java
API描述:
	另一种方法是声明实现 Runnable 接口的类。
	该类然后实现 run 方法。
	然后可以分配该类的实例，
	在创建Thread 时作为一个参数来传递并启动。
步骤:
	a.创建实现类 implements Runnable
	b.重写接口中的run方法(写任务代码)
    c.创建实现类对象(称为任务对象)  
    d.创建Thread对象,同时传入实现类对象
    e.启动Thread对象(调用start方法)
      
/**
 * 1.创建实现类 实现 Runnable接口
 */
public class MyRunnable implements Runnable{
    //2.重写run方法
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("听歌" + i);
        }
    }
}

public class TestDemo {
    public static void main(String[] args) {
        //3.创建实现类对象(任务对象)
        MyRunnable mr = new MyRunnable();
        //4.创建Thread对象,同时传入实现类对象
        Thread t = new Thread(mr);
        //5.开启线程
        t.start();

        //主线程的代码
        for (int i = 0; i < 100; i++) {
            System.out.println("吃饭" + i);
        }
    }
}  
```

- 继承方式和实现方式的对比

```java
实现方式比继承方式好:
a.由于Java单继承,继承方式不能继承别的类
b.实现方式可以让多个线程共享同一个任务资源
c.实现方式可以让线程对象和任务对象解耦,线程是线程,任务是任务,是分别独立
d.以后学习的线程池,只能放入任务对象,而不能放入线程对象
总结: 以后在开发中尽可能使用实现方式
```

##### 6.匿名内部类简化线程创建方式***************

```java
public class TestDemo {
    public static void main(String[] args) {
        //1.创建线程的方式一
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println("吃饭" + i);
                }
            }
        }.start();

              //2.创建线程的方式二
        new Thread(new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println("听歌" + i);
                }
            }
        }).start();

        //主线程
        for (int i = 0; i < 100; i++) {
            System.out.println("抽烟" + i);
        }
    }
}
```



#### 总结

```java
"能够理解冒泡排序的执行原理
"能够理解选择排序的执行原理
"能够理解二分查找的执行原理 

能够辨别程序中异常和错误的区别
	异常: 程序员造成的,可以解决的
	错误: 一般是硬件或者系统本身引起,软件程序员解决不了
"说出异常的分类
	Throwable
		|- Exception
			|- Exception以及其子类(RuntimeException除外),编译时异常
			|- RuntimeException以及其子类,运行时异常
		|- Error
列举出常见的三个运行期异常
	NullPointerException
	ArrayIndexOutOfBoundsException
	ClassCastException
	
"能够使用try...catch关键字处理异常
	public static void main(String[] args){
		try{
			method();
		}catch(XxxException e){
			e.printStackTrace();
		}
	}
	public static void method()throws XxxException{
		//...
	}
"能够使用throws关键字处理异常
	public static void main(String[] args)throws XxxException{
		method();
	}
	public static void method()throws XxxException{
		//...
	}
能够自定义并使用异常类
	
"说出进程和线程的概念
	进程: 在内存中正在运行的程序
	线程: 进程中完成某个功能的执行单元
"能够理解并发与并行的区别
	并发: 多个事件在同一时间段内执行(交替执行)
	并行: 多个事件在同一时刻同时执行(真的一起执行)
能够描述Java中多线程运行原理
	多线程运行原理:就是线程并发,就是CPU的线程调度
"能够使用继承类的方式创建多线程
	public class 子线程 extends Thread{
		重写run方法,写上任务代码
	}
	public static void main(String[] args){
		创建线程对象
		调用线程对象的start方法开启线程
	}
"能够使用实现接口的方式创建多线程
	public class 任务类 implements Runnable{
		重写run方法,写上任务代码
	}
	public static void main(String[] args){
		创建任务类对象
		创建线程对象,通过构造参数传入任务对象
		开启线程
	}

能够说出实现接口方式的好处
"能够使用匿名内部类快速创建线程对象"
```



