## day11【Properties类、缓冲流、转换流、序列化流、装饰者模式、commons-io工具包】

### 一.IO流的异常处理

##### 1.JDK7之前的标准IO处理

```java
//JDK7标准的IO异常处理代码
public static void method01() {
    //1.创建字符输出流
    FileWriter fr = null;
    try {
      fr = new FileWriter("1.txt");
      //2.写数据
      fr.write("HelloWorld");
    } catch (IOException ie) {
      ie.printStackTrace();
    } finally {
      //写必须要执行的代码,释放资源的代码
      //3.释放资源 
      try {
        if (fr != null) {
          fr.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
}
```

##### 2.JDK7引入的IO处理

```java
//JDK7的时候引入了try-with-resource异常处理代码
public static void method02() {
    //1.创建字符输出流
    try (FileWriter fr = new FileWriter("1.txt")) {
      //2.写数据
      fr.write("HelloWorld");
    } catch (IOException ie) {
      ie.printStackTrace();
    }
} 
```

### Properties类

##### 1.Properties类的介绍

```java
Properties类:表示了一个持久的属性集
集:集合
属性集: 键值对的集合
持久的: 可以直接和硬盘打交道的
```

##### 2.构造方法

```java
注意:Properties实现类的Map,但是泛型确定了,属性名和属性值(键和值)都是String类型
public Properties(); //创建一个空内容的属性集对象
```

##### 3.基本保存数据的方法

```java
和数据相关的方法
public void setProperty(String key,String value);//相当于Map的put方法
public String getProperty(String key);//相当于Map的get方法
public Set<String> stringPropertyNames();//相当于Map的keySet方法
其他操作数据的方法就是Map中的方法,没有特有的了

public class TestPropertiesDemo {
    public static void main(String[] args) {
        //1.创建一个Properties对象
        Properties ps = new Properties();
        //2.对ps对象操作数据
        ps.setProperty("xiaomi6s", "1888"); //相当于put方法
        ps.setProperty("sanxingNote11", "3888");//相当于put方法
        ps.setProperty("huaWeiP30", "4888");//相当于put方法
        ps.setProperty("iphone11Pro", "8888");//相当于put方法
        System.out.println(ps);
        //3.获取数据
        String value = ps.getProperty("iphone11Pro");//相当于get方法
        System.out.println(value);
        //4.keySet方法
        Set<String> propertyNames = ps.stringPropertyNames();//相当于keySet方法
        System.out.println(propertyNames);
    }
}
```

##### ==4.持久化的方法==

```java
什么是持久化的方法:就是和硬盘交互的方法
public void store(OutputStream out/Writer w); //保存
public void load(InputStream in/Reader r); //读取

public class TestPropertiesDemo {
    public static void main(String[] args) throws IOException {
        //1.创建一个Properties对象
        Properties ps = new Properties();
        //2.对ps对象操作数据
//        ps.setProperty("xiaomi6s", "1888"); //相当于put方法
//        ps.setProperty("sanxingNote11", "3888");//相当于put方法
//        ps.setProperty("huaWeiP30", "4888");//相当于put方法
//        ps.setProperty("iphone11Pro", "8888");//相当于put方法
        System.out.println(ps);
        //3.Properties中和持久化有关的方法
        // 保存到文件中
        //ps.store(new FileWriter("1.txt"),"this is a test file");
        // 从文件中读取
        ps.load(new FileReader("1.txt"));
        System.out.println(ps);
    }
}
注意: 如果是Properties持久化后的文件,我们建议使用xxx.properties作为后缀,建议把1.txt改为1.properties
```

### 三.缓冲流

##### 1.缓冲流的作用

```java
缓冲(Buffered)流,也称为高效流,它是对普通流的增强(性能方面的增强)
```

##### 2.缓冲流的分类

```java
字节输出流(OutputStream) ---> 缓冲字节输出流(BufferedOutputStream)
字节输入流(InputStream) ---> 缓冲字节输入流(BufferedInputStream)
  
字符输出流(Writer) ---> 缓冲字符输出流(BufferedWriter)
字符输入流(Reader) ---> 缓冲字符输入流(BufferedReader)
  
缓冲流的构造方法:
	public 缓冲流(普通流); //创建一个缓冲流对象,构造时需要传入普通流对象
```

##### ==3.字节缓冲流的介绍和使用==

- 字节缓冲流的构造

  ```java
  public BufferedOutputStream(OutputStream out);//创建一个字节缓冲输出流,需要一个普通字节输出流
  public BufferedInputStream(InputStream in);//创建一个字节缓冲输入流,需要一个普通字节输入流
  ```

- 字符缓冲流的高效测试

  ```java
  public class BufferedDemo01 {
      public static void main(String[] args) throws IOException {
          long start = System.currentTimeMillis();
          copy03();
          long end = System.currentTimeMillis();
          System.out.println("耗时:" + (end - start) + "毫秒");
      }

      //普通流
      //一节课过去了...
      public static void copy01() throws IOException {
          //1.创建2个普通流对象
          FileInputStream fis = new FileInputStream("E:\\1.avi");
          FileOutputStream fos = new FileOutputStream("copy.avi");
          //2.复制(一个一个字节)
          int b = 0;
          while ((b = fis.read()) != -1) {
              fos.write(b);
          }
          //3.释放资源
          fos.close();
          fis.close();
      }
      //缓冲流
      //耗时:3447毫秒
      public static void copy02() throws IOException {
          //1.创建一个缓冲字节输出流
          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy02.avi"));
          //2.创建一个缓冲字节输入流
          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\1.avi"));
          //3.复制(一个一个字节)
          int b = 0;
          while ((b = bis.read()) != -1) {
              bos.write(b);
          }
          //4.释放资源
          bis.close();
          bos.close();
      }

      //缓冲流
      //耗时:238毫秒
      public static void copy03() throws IOException {
          //1.创建一个缓冲字节输出流
          BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy03.avi"));
          //2.创建一个缓冲字节输入流
          BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\1.avi"));
          //3.复制(一个字节数组)
          byte[] bs = new byte[1024 * 16];
          int len = 0;
          while ((len = bis.read(bs)) != -1) {
              bos.write(bs, 0, len);
          }
          //4.释放资源
          bis.close();
          bos.close();
      }
  }
  ```

##### ==4.字符缓冲流的介绍和使用==

- a.字符缓冲流的构造

  ```java
  public BufferedWriter(Writer w);//创建字符缓冲输出流,传入普通字符输出流
  public BufferedReader(Reader r);//创建字符缓冲输入流,传入普通字符输入流
  ```

- b.字符缓冲流的2个特有方法

  ```java
  BufferedWriter中有一个特有方法:
  	public void newLine(); //写一个跨平台的换行符

  public class BufferedDemo02 {
      public static void main(String[] args) throws IOException {
          //1.字符缓冲输出流
          BufferedWriter bw = new BufferedWriter(new FileWriter("1.txt"));
          //2.写数据
          for (int i = 0; i < 10; i++) {
              bw.write("java");
              //bw中有一个特有方法
              bw.newLine();//写一个跨平台的换行
          }
          //3.释放资源
          bw.close();
      }
  }

  BufferedReader中有一个特有方法:
  	public String readLine();一次读取一行(以换行符为标准)
        
  public class BufferedDemo03 {
      public static void main(String[] args) throws IOException {
          //1.字符缓冲输入流
          BufferedReader br = new BufferedReader(new FileReader("1.txt"));
  //        String line = br.readLine();//BufferedReader的特有方法:一次读取一行
  //        System.out.println(line);
          //===========BufferedReader一次读取一行的标准循环代码============
          String line = "";//用来接收读取的一行数据
          while ((line = br.readLine()) != null) {
              System.out.println(line);
          }
          //3.释放资源
          br.close();
      }
  }      	
  ```

##### ==5.综合练习:文本排序==

```java
需求:
	将一个文件中的文本读取出来,按照序号排序,排序完毕之后写到另外一个文本中
public class TestDemo {
    public static void main(String[] args) throws Exception {
        //0.事先准备一个集合
        ArrayList<String> csb = new ArrayList<String>();
        //1.使用缓冲字符输入流
        BufferedReader br = new BufferedReader(new FileReader("csb.txt"));
        //2.读数据
        String line = null;
        while ((line = br.readLine()) != null) {
            //保存到集合中
            csb.add(line);
        }
        //3.释放资源
        br.close();

        //4.排序
        Collections.sort(csb, (o1, o2) -> o1.charAt(0) - o2.charAt(0));////按照字符串的一个字母升序排序
        //5.写入到另外一个文件中
        BufferedWriter bw = new BufferedWriter(new FileWriter("sort_csb.txt"));
        //6.写数据
        for (String cs : csb) {
            //写每一行
            bw.write(cs);
            //换行
            bw.newLine();
        }
        //7.释放资源
        bw.close();
    }
}
	
```



### 四.转换流

##### 1.字符编码(编码和解码)

```java
什么是字符编码:
	一套规则,规定了不同字符对应的码值,比如'a' -- 97, 'A' -- 65, '0' -- 48 
      
编码: 把字符变成对应码值,比如: 'a' ---> 97(0110 0001)
解码: 把对应的码值变回字符, 比如 0110 0001 --> 'a'  
```

##### 2.字符集

```java
什么是字符集:
	一个系统中支持的所有字符的集合(包括文本,数值,标点符号,图形符号) 
      
常见的字符集和字符编码
a."ASCII字符集":有英文字母,英文符号,数字(一共127个),"每个字符占1个字节"
	对应的编码:"ASCII编码"
      
b."GBxxx字符集":
		"GB2312字符集":含有常用的简体汉字(7000多个),标点和数字,每个中文占两个字节
         "GBK字符集": 含有大部分简体和繁体汉字还包括日韩文字(20000多个),标点和符号,每个中文占2个字节
		"GB18030字符集":基本包含了所有汉字(包括少数民族,大概70000多个),标点和符号,每个中文占2个字节
         对应的编码:"GBK编码",在GBK编码中"所有中文占2个字节"
           
c."Unicode字符集":
          包含了世界上绝大多数国家的文字,标点,符号. 
          对应的编码:Unicode编码,UTF-8编码,UTF-16,UTF-32编码,
		 我们在开发中一般使用"UTF-8编码",在此编码中"一个中文占3个字节"         
d."ISO-8859-1字符集":
		拉丁文字符集(西欧国家)
         以后我们学的服务器(Tomcat),在6.0版本以前默认使用的就是ISO-8859-1字符集
           
总结:
	"a.所有字符集都会兼容ASCII字符集
	"b.对于中国人有用的:
			"GBK字符集 -- GBK编码 -- 一个中文2字节
           	 "Unicode字符集 -- UTF-8编码 -- 一个中文3个字节
```

##### 3.编码引出的问题

```java
一个文件假设是UTF-8编码,那么如果读取时使用GBK进行解码,肯定会出现乱码

常识: IDEA默认使用UTF-8
  	  记事本默认使用GBK编码(Notepad++可以自己选择编码)
  
//假设记事本文件2.txt采用GBK编码,而Idea默认使用UTF-8编码,编码不一致,必然会有乱码
//怎么解决: a.把Idea改成GBK编码 b.把文件改为UTF-8
public class TestLuanMaDemo {
    public static void main(String[] args) throws IOException {
        //1.创建一个字符输入流
        FileReader fr = new FileReader("2.txt");
        //2.读取一个字符
        int ch = fr.read();
        System.out.println((char) ch);
        //3.释放资源
        fr.close();
    }
}
```

##### ==4.使用转换流InputStreamReader解决中文问题==

- InputStreamReader 转换输入流(字符流),在读取文本文件时,指定使用的编码


- 构造方法

  ```java
  public InputStreamReader(InputStream in,String charsetName); //指定使用何种编码读取文件
  public InputStreamReader(InputStream in); //使用工具默认的编码读取文件
  ```

- 使用InputStreamReader读取不同编码的文件(代码演示)

  ```java
  /**
   * 使用InputStreamReader指定编码读文件
   */
  public class TestInputStreamReaderDemo {
      public static void main(String[] args) throws Exception {
          //1.创建InputStreamReader
          InputStreamReader isr = new InputStreamReader(new FileInputStream("gbk.txt"), "GBK");//文件GBK,指定读取时使用GBK
          InputStreamReader isr = new InputStreamReader(new FileInputStream("utf8.txt"), "UTF-8");//文件U8,指定读取时使用U8
          InputStreamReader isr = new InputStreamReader(new FileInputStream("utf8.txt"), "GBK");//文件U8,指定读取时使用GBK
          //2.读数据
          int ch = isr.read();
          System.out.println((char) ch);

          ch = isr.read();
          System.out.println((char) ch);
          //3.释放资源
          isr.close();
      }
  }
  ```

##### ==5.使用转换流OutputStreamWriter写中文==

- OutputStreamWriter:转换输出流(字符流),在写入文本文件时,指定使用的编码 


- 构造方法

  ```java
  public OutputStreamWriter(OutputStream out,String charsetName);指定使用何种编码写入文件
  public OutputStreamWriter(OutputStream out);使用工具默认的编码写入文件
  ```

- 输出指定编码的中文

  ```java
  /**
   * 指定编码写文本文件
   */
  public class TestOutputStreamWriterDemo {
      public static void main(String[] args) throws Exception {
          //1.创建OutputStreamWriter对象
          OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("gbk.txt"), "GBK");
          OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("utf8.txt"), "UTF-8");
          //2.写数据
          osw.write("你好");
          //3.释放资源
          osw.close();
      }
  }

  注意:
  	如果使用windows自带的记事本创建文本文件,那么该文件默认使用GBK编码
  	如果使用windows自带的记事本打开文本文件,会根据文件的编码选择合适的格式打开
  	(不会有乱码,除法文件本身就是乱码)
  ```

##### ==6.练习:转换文件编码==

```java
需求:
	将GBK编码的文本文件，转换为UTF-8编码的文本文件。
a.先使用InputStreamReader指定GBK编码读取
b.再使用OutputStreamWriter指定U8编码写入新的文件中

/**
 * 需求:
 * 将GBK编码的文本文件，转换为UTF-8编码的文本文件。
 */
public class TestTransferEncodingDemo {
    public static void main(String[] args) throws Exception {
//        a.先使用InputStreamReader指定GBK编码读取
        InputStreamReader isr = new InputStreamReader(new FileInputStream("gbk.txt"), "GBK");
//        b.再使用OutputStreamWriter指定U8编码写入新的文件中
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("utf8.txt"), "UTF-8");
        //复制
        int ch = 0;
        while ((ch = isr.read()) != -1) {
            osw.write(ch);
        }
        //释放资源
        osw.close();
        isr.close();
    }
}
```

### 五.序列化流

##### 1.什么是序列化流

```java
序列化流,其实就是操作对象的流
序列化流有2种:
	序列化流: 写对象的流,ObjectOutputStream
	反序列化流: 读对象的流,ObjectInputStream
```

##### 2.ObjectOutputStream的介绍和使用

- 构造方法

  ```java
  public ObjectOutputStream(OutputStream out);//创建对象的输出流,需要一个普通的字节输出流
  ```

- 序列化操作的前提

  ```java
  被序列化的类必须实现java.io.Serializable接口,才能启用其序列化功能
  此接口没有任何抽象方法,一般这种接口我们称为标记接口
  ```

- ==序列化操作(代码演示)==

  ```java
  public class TestObjectOutputStreamDemo {
      public static void main(String[] args) throws IOException {
          //1.创建一个ObjectOutputStream对象
          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("1.txt"));
          //2.写一个对象
          Dog wangcai = new Dog(2, "旺财");
          //NotSerializableException
          oos.writeObject(wangcai);
          //3.释放资源
          oos.close();
      }
  }
  ```

##### 3.ObjectInputStream的介绍和使用

- 构造方法

  ```java
  public ObjectInputStream(InputStream in);创建反序列化流,需要普通的字节输入流
  ```

- ==反序列操作(正常演示)==

  ```java
  public class TestObjectInputStreamDemo {
      public static void main(String[] args) throws IOException, ClassNotFoundException {
          //1.创建ObjectInputStream对象
          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("1.txt"));
          //2.读对象
          Object obj = ois.readObject();
          System.out.println(obj);
          //3.释放资源
          ois.close();
      }
  }
  ```

- 反序列化操作的两种错误演示

  ```java
  a.InvalidClassException:无效类异常
  	在序列化后,反序列化前,对原有Java类进行修改	
  b.ClassNotFoundException 找不到类异常
  	在序列化后,反序列化前,删除原有类
  	
  扩展:
  	1.序列化流和反序列化流是以何种机制来判断一个类是否有效的呢???
      根据类的序列化版本号来判定的
      原理:
  		当一个类实现了java.io.Serializable接口后,编译器就会给该类生成一个序列化版本号(根据类的内容生成的).序列化时会把版本号也序列化进去,当我们修改类之后,序列化版本号会重新计算,跟原来的版本号就会不一致,反序列化时就会对比原来的版本号和现在的版本,如果发现不一致,抛出InvalidClassException异常
  	2.Java允许版本号交给程序员自己手动管理
  		只要在类中定义一个版本号常量即可,这个常量必须符合以下格式:
  		public static final long serialVersionUID = 值;
  	3.关键字transient
  		称为瞬态关键字
  		作用: 用来修饰成员变量
  		被transient修饰的成员变量和不被transient修饰的成员变量,在使用上没有任何区别
  		被transient标记成员变量,序列化时会忽略它	
  ```

##### ==4.练习:如果需要序列化多个对象怎么操作?==

```java
思考:
	如果需要序列化多个对象怎么操作?
解决:
	创建一个集合对象,把需要序列化的多个对象保存到该集合对象中,然后以集合作为对象进行序列化和反序列化
	
public class TestObjectStreamDemo {
    public static void main(String[] args) throws Exception {
//        write();
        read();
    }
    public static void read() throws IOException, ClassNotFoundException {
        //1.创建反序列化流对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("dogs.txt"));
        //2.读对象
        ArrayList<Dog> dogs = (ArrayList<Dog>) ois.readObject();
        for (Dog dog : dogs) {
            System.out.println(dog);
        }
        //3.释放资源
        ois.close();
    }

    public static void write() throws IOException {
        //1.多个对象,保存到集合中
        ArrayList<Dog> dogs = new ArrayList<Dog>();
        //2.添加多个对象
        dogs.add(new Dog(1, "旺小财"));
        dogs.add(new Dog(2, "旺中财"));
        dogs.add(new Dog(3, "旺大财"));
        dogs.add(new Dog(4, "旺老财"));
        dogs.add(new Dog(5, "旺死财"));
        dogs.add(new Dog(6, "旺灰财"));
        //3.创建序列化流对象
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("dogs.txt"));
        //4.写对象
        oos.writeObject(dogs);
        //5.释放资源
        oos.close();
    }
}	
```

### 六.打印流

##### 1.打印流PrintStream的介绍

```java
专门用于打印数据的流PrintStream
a.打印流不会抛出IO异常
b.打印流可以打印任何数据类型(所见即所得)  
```

##### ==2.PrintStream的构造和常用方法==

```java
构造方法:
	public PrintStream(String pathname);
	public PrintStream(File file);
	public PrintStream(OutputStream out);
成员方法:
	public void print(任意类型); //打印数据后,不带换行
	public void println(任意类型); //打印数据后,带跨平台换行

public class TestPrintStreamDemo {
    public static void main(String[] args) throws FileNotFoundException {
        //1.创建PrintStream对象
        PrintStream ps = new PrintStream("print.txt");
        //2.打印数据
//        ps.print(97);
//        ps.print('a');
//        ps.print('中');
//        ps.print("java");
//        ps.print(3.14);
//        ps.print(true);
        ps.println(97);
        ps.println('a');
        ps.println('中');
        ps.println("java");
        ps.println(3.14);
        ps.println(true);
        //3.释放资源
        ps.close();
    }
}
```

##### 3.扩展_修改打印流的流向

```java
public class TestPrintStreamDemo02 {
    public static void main(String[] args) throws FileNotFoundException {
        PrintStream ps = System.out;

        ps.println("HelloWorld");

        //思考,如何我们自己创建一个打印流,赋值给System.out
        //会怎么样?
        PrintStream pss = new PrintStream("1.txt");
        //因为out是由final修饰的
        //System.out = pss;
        //修改系统打印流的方向
        System.setOut(pss);

        System.out.println("HelloWorld");
        System.out.println("HelloWorld");
        System.out.println("HelloWorld");
    }
}
注意:开发中不要修改System.out的方向
```

### 第七章 装饰设计

##### 1.装饰模式作用

```java
在不改变原有类的代码情况下,对原有类进行功能的增强,比如我们的缓冲流其实就是采用装饰设计模式
```

##### 2.装饰者设计模式的4个基本步骤

- 装饰类和被装饰类必须实现相同的接口
- 在装饰类中必须传入被装饰类的引用
- 在装饰类中对需要扩展的方法进行扩展
- 在装饰类中对不需要扩展的方法调用被装饰类中的同名方法

##### 3.代码实现

```java
/**
 * 歌星接口
 */
public interface SingStar {
    /**
     * 唱歌
     */
    void sing();

    /**
     * 跳舞
     */
    void dance();
}

/**
 * 被装饰类:刘德华
 */
public class LiuDeHua implements SingStar {
    @Override
    public void sing() {
        System.out.println("啊哈,给我一杯忘情水~~");
    }

    @Override
    public void dance() {
        System.out.println("蹦恰恰~~~蹦恰恰~~~");
    }
}

/**
 * 刘德华的装饰类
 */
public class LiuDeHuaWrapper implements SingStar{

    private LiuDeHua ldh;

    public LiuDeHuaWrapper(LiuDeHua ldh){
        this.ldh = ldh;
    }

    @Override
    public void sing() {
        System.out.println("先嗷嗷练练嗓子...");
        ldh.sing();
        System.out.println("喝点热水,润润喉...");
    }

    @Override
    public void dance() {
        ldh.dance();
    }
}

public class TestDecorationDemo {
    public static void main(String[] args) {
        //1.使用原类
        LiuDeHua ldh = new LiuDeHua();
        ldh.sing();
        ldh.dance();
        //2.使用装饰类
        LiuDeHua ldh = new LiuDeHua();
        LiuDeHuaWrapper wrapper = new LiuDeHuaWrapper(ldh);
        wrapper.sing();
        wrapper.dance();
    }
}
```

### 第八章 commons-io工具包

##### 1.commons-io的介绍和下载

```java
commons-io是有第三方公司apache提供开源小框架
下载:http://commons.apache.org/proper/commons-i
```

##### 2.常用API介绍

- 复制文件API(使用IOUtils)

  ```java
  public static int copy(InputStream in, OutputStream out)；复制文件(2G以下)
  public static long copyLarge(InputStream in, OutputStream out)；复制文件(2G以上)
  ```

- 复制文件到某个文件夹下(使用FileUtils)

  ```java
   public static void copyFileToDirectory(File srcFile,File destFile); 
  ```

- 复制文件夹API(使用FileUtils)

  ```java
   public static void copyDirectoryToDirectory(File file1 ,File file2 );
  ```

- 代码实现

  ```java
  public class TestFileUtilsDemo {
      public static void main(String[] args) throws IOException {
          //1.复制单个文件(2GB以下)
          IOUtils.copy(new FileInputStream("G:\\upload\\222.png"),new FileOutputStream("copy.png"));
          //2.复制单个文件(2GB以上)
          IOUtils.copyLarge(new FileInputStream("G:\\upload\\333.png"),new FileOutputStream("copy3.png"));
          //3.复制文件到某个文件夹下
          FileUtils.copyFileToDirectory(new File("G:\\upload\\1546241961620.png"),new File("H:\\BaiduNetdiskDownload")); 
          //4. 复制某个文件夹到某个文件夹下
          FileUtils.copyDirectoryToDirectory(new File("G:\\uploads"), new File("H:\\BaiduNetdiskDownload"));
      }
  }
  ```

  ​